本项目为HUST-2019级-数据结构课设, 仅供参考.

按照编译过程, 可将该项目分为几个过程: 

1. 预处理(preprocess)
2. 词法分析(lexical analyze)
3. 语法分析(syntax analyze)

分别来说一下

##### 1. 预处理( 文件包含 和 宏定义 )

​	这方面指导书上面没有具体指导方法, 在网络上随手一搜也没找到具体说明, 我自己在这上面做的很简陋, 非常不鲁棒.

​	整个过程就是将源文件挨个字符读进来, 当读到#include 和  #define 时候就调用相应函数处理.

###### 1. 文件包含

​	这个蛮简单的, 因为我为了操作方便, 将源文件读到了字符串里面. 这样文件包含的时候将相应文件接着读到该字符串就行.

######  2. 宏定义

  这个我是先将所有 宏名 和  替换的字符串 保存下来 , 在第一遍扫描结束后(源文件已经读到了字符串里面, 文件包含也已经完成), 在字符串里面查找宏名, 并将其替换为 相应的字符串.  但这就会产生一个问题 : 我用的是简单的std::string.find(str), 这时候还没有进行词法分析, 没有单词(token) 的概念, 所以遇到符合的就会替换, 有时候会产生意外, 将不该替换的替换掉了. 举个栗子

```c++
#define i  j
int i, j;
```

 如果正常来讲, 宏定义展开后应该产生

```c++
int j, j;
```

~~(我也不知道为什么随手举了一个语法错误的栗子)~~

但是按我的实现 就会变成

```c++
jnt j, j;
```

如果已经经过了词法分析, 我们就可以避免出现这种情况. 

但是在词法分析后,  再去替换, 哪有这样的预处理呢?(菜鸡发问)

还有就是词法分析后需要自己再去写函数去比对, 不如std::string.find(str) 来得方便. 

不知道是不是多趟扫描的?



##### 2. 词法分析

词法分析针不戳, 主要就是用到了有限状态机的思想, 很无敌.

我感觉蛮有趣的(想象一下 程序是一个小人,  在不同状态之间跳来跳去的).

词法分析的重点是画图, 把状态机的状态转换图画好, 对着翻译就好了. 轮子哥有一篇教程是讲这个的, 强烈推荐!(我基本上也是照着这个来的).自己跟着做就好了. 我自己的状态转换图在State Machine.drawio 里面 (很简陋, 画完发现UML分类里面有专门的State图 , 害).

[轮子哥词法分析教程](http://www.cppblog.com/vczh/archive/2014/03/02/206014.html)

##### 3. 语法分析

~~(没想到这么快,  我以为我能讲很多的)~~

看书! 清华出版社的<<编译原理>> 重点是第四章, 递归下降用就完事了. 不过注意, 你所选取的C语言的子集必须是LL(1) 文法, 所以有可能用到 **消除左递归** 和 **提取左公因子**. 这两项多了以后, 如果你按照课本上面的记号, 你会发现有一堆引号(说的就是我) , 比如 产生 A'  A''  A"'. 我没仔细想这些有什么合适的语法名称(如果仔细研究的话很可能有), 就直接叫XXX_SingleQuota,  XXX_DoubleQuota, 这方面挺失败的吧!  因为这个会影响到你下面的打印抽象语法树, 搞出来的语法单元节点的名称非常难看.



这里也不算难, 只要把SELECT集合计算正确. 算出来可以检验下 相同字符的SELECT集合不要重合, 否则很可能没有消除左递归或者提取左公因式. 而且注意SELECT集合不同情况下的处理是不同的, 比如有时候可能推导出空, 那么就会并上 FOLLOW(xxx), 大多数时候这个SELECT集合的字符是由前面所Match的, 所以这时候不必读取新的字符直接返回就好了. ~~(这一段如果没看懂就是我讲的不好, 我也感觉自己讲的很抽象, 动手做的时候你可能会明白(或者一开始就很明白, 根本不像我一样掉进了这个坑里面))~~

当然, 忘了说了, 比较重要的是定义好你的语法结构, 我是照抄的任务书. 熟悉了以后你就可以随便加状态了.  比如 我的 if() O, O必须是一个语句, 而不能是复合语句, 也就是说if() { xxx } 是不行的.

你只要在相关SELECT集合里面加上相关字符, 就很容易加上各自复杂语法结构了.

##### 3.5 打印语法树 和 格式化输出

这个没什么可说的,递归下降就是按先序遍历产生的语法单元节点, 按照先序遍历打印就可以了. 格式化输出更是简单的一批.



说点其他杂乱的吧 :

首先推荐几个我觉得很有用的工具

1. [极为便利的画图工具](https://app.diagrams.net/)  这玩意画图老好用了, 真香 !
2. [c++字典 ](https://en.cppreference.com/w/)  忘了一查就管用, 有例子教你咋用, 各方面都全, 爽!
3. git  这个就不用多说了, 只要及时commit, 随便瞎改都可以(虽然我一次版本回退都没用过), 而且每次git commit /git push 都很有成就感, 不是吗?



再说点别的

一个是 我尽量使用智能指针来管理满天飞的指针(包括文件指针), 挺好的, 锻炼锻炼, 我尽量使代码具有c++感, 而不是c + STL

第二个是我花了大半天, 重构了整个程序(调整不合理的程序结构, 画UML类图, 根据[google c++ 编程规范](https://google.github.io/styleguide/cppguide.html)  改名字 和写注释)

提前设计好结构还是很重要的, 不然重构时候真的很头疼 : vsc的重构体验也不是很好, 我改个名字连标准库的同名变量都拿出来问我要不要改.

不过我最开始想的是, 能跑起来就行,  所以乱糟糟的. (当然, 重构之后也就稍微好了一点点, 毕竟之前没什么写2k行程序的经验).

写注释呢, 我真的很想写丰富一点, 但是我觉得也没啥可写的, 逻辑上面确实没有什么难处, 我已经尽力把变量名字写长长长, 大家应该能明白的.



最后提一下环境:

vmware workstation 里面 ubuntu虚拟机,  vscode  ssh 过来写代码, 在windows下画图, 用github 同步两边.



ps:想起来我写的可能有点奇怪, 每个步骤搞一个类型, 我的本意是把处理的数据和操作结合起来, 而且对于不同的文件还可以搞多个对象分别处理. 后来发现纯属想多了, 而且这样有点蠢,,  应该再写一个类, 把main.cc里面的那几个操作包装起来, 并且提供 -usage 提供不同参数指定不同操作.

我之所以说下这个是因为我后来想到, 直接重载类的调用运算符写成一个callable object会不会更好一点, 可能吧.

